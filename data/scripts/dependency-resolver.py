#!/usr/bin/env python3

# This file is part of the Soletta (TM) Project
#
# Copyright (C) 2015 Intel Corporation. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import json
import logging
import os
import pickle
import platform
import re
import socket
import subprocess
import sys
import tempfile
import shlex
from shutil import which, move

default_compiler = "gcc"
cstub = "{headers}\nint main(int argc, char **argv){{\n {fragment} return 0;\n}}"
log_disclaimer = "This file was generated by Soletta's dependency resolver script to help debugging configuration issues."

class DepContext:
    def __init__(self, config_log):
        self.kconfig = {}
        self.makefile_vars = {}
        self.log_file = config_log
        self.logger = None

    def add_kconfig(self, k, t, v):
        self.kconfig[k] = {"value": v, "type": t}
        self.debug("Adding kconfig entry: %s %s %s", k, t, v)

    def get_kconfig(self):
        return self.kconfig

    def add_makefile_var(self, k, v, attrib, overwrite):
        curr = self.makefile_vars.get(k)
        curr_val = v

        if curr and curr["attrib"] == attrib:
            if overwrite:
                curr_val = v
            else:
                curr_val = "%s %s" % (curr["value"], v)

        self.makefile_vars[k] = {"value": curr_val, "attrib": attrib}
        self.debug("Adding Makefile.gen entry: %s %s %s", k, attrib, curr_val)

    def add_append_makefile_var(self, k, v, overwrite=False):
        self.add_makefile_var(k, v, "+=", overwrite)

    def add_cond_makefile_var(self, k, v, overwrite=False):
        self.add_makefile_var(k, v, "?=", overwrite)

    def get_makefile_vars(self):
        return self.makefile_vars

    def find_makefile_var(self, v):
        var = self.makefile_vars.get(v)
        if var:
            return var["value"]
        return ""

    def __getstate__(self):
        d = self.__dict__.copy()
        if 'logger' in d.keys():
            d['logger'] = d['logger'].name
        return d

    def __setstate__(self, d):
        if 'logger' in d.keys():
            d['logger'] = logging.getLogger(d['logger'])
        self.__dict__.update(d)

    def logger_init(self):
        if self.logger:
            return

        if os.path.isfile(self.log_file):
            move(self.log_file, "%s.old" % self.log_file)

        self.logger = logging.getLogger("dependency-resolver")
        self.logger.setLevel(logging.DEBUG)

        fh = logging.FileHandler(self.log_file)
        fh.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)

        formatter = logging.Formatter("%(message)s")
        fh.setFormatter(formatter)
        ch.setFormatter(formatter)

        self.logger.addHandler(fh)
        self.logger.addHandler(ch)

    def debug(self, msg, *args, **kargs):
        self.logger_init()
        self.logger.debug(msg, *args, **kargs)

    def info(self, msg, *args, **kargs):
        self.logger_init()
        self.logger.info(msg, *args, **kargs)

def run_command(cmd, context):
    try:
        context.debug("Command: %s", cmd)
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT,
                                         shell=True, universal_newlines=True)
        context.debug("Command output(stdout):\n%s", output if output else "None")
        return output.replace("\n", "").strip(), True
    except subprocess.CalledProcessError as e:
        context.debug("exit code: %s", e.returncode)
        context.debug("Command output(stderr):\n%s", e.output)
        return e.output, False

def handle_pkgconfig_check(args, conf, context):
    dep = conf["dependency"].upper()
    pkg = conf["pkgname"]
    atleast_ver = conf.get("atleast-version")
    max_ver = conf.get("max-version")
    exact_ver = conf.get("exact-version")
    ver_match = True

    if exact_ver:
        cmd = "%s --exact-version=%s %s" % (args.pkg_config, exact_ver, pkg)
        result, status = run_command(cmd, context)
        if not status:
            ver_match = False
    elif atleast_ver:
        cmd = "%s --atleast-version=%s %s" % (args.pkg_config, atleast_ver, pkg)
        result, status = run_command(cmd, context)
        if not status:
            ver_match = False
    elif max_ver:
        cmd = "%s --max-version=%s %s" % (args.pkg_config, max_ver, pkg)
        result, status = run_command(cmd, context)
        if not status:
            ver_match = False

    cflags_stat = None
    ldflags_stat = None
    if ver_match:
        cflags_cmd = "%s --cflags %s" % (args.pkg_config, pkg)
        ldflags_cmd = "%s --libs %s" % (args.pkg_config, pkg)

        cflags, cflags_stat = run_command(cflags_cmd, context)
        ldflags, ldflags_stat = run_command(ldflags_cmd, context)

        if cflags_stat:
            context.add_cond_makefile_var("%s_CFLAGS" % dep, cflags)

        if ldflags_stat:
            context.add_cond_makefile_var("%s_LDFLAGS" % dep, ldflags)

        if cflags_stat or ldflags_stat:
            context.add_cond_makefile_var("%s_REQUIRES_PRIVATE" % dep, pkg)

    success = (cflags_stat or ldflags_stat) and ver_match
    have_var = "y" if success else "n"
    context.add_kconfig("HAVE_%s" % dep, "bool", have_var)

    return success

def compile_test(source, compiler, cflags, ldflags):
    f = tempfile.NamedTemporaryFile(suffix=".c",delete=False)
    f.write(bytes(source, 'UTF-8'))
    f.close()
    output = "%s-bin" % f.name
    cmd = "{compiler} {cflags} {src} -o {out} {ldflags}".format(compiler=compiler,
            cflags=cflags, ldflags=ldflags or "", src=f.name, out=output)
    context.debug("Compiling source code:\n%s", source)
    out, status = run_command(cmd, context)
    if os.path.exists(output):
        os.unlink(output)
    os.unlink(f.name)

    return status

def set_makefile_compflags(flags, prefix, suffix):
    append_to = flags.get("append_to")
    flag_value = flags.get("value")

    if not flag_value:
        return

    if append_to:
        context.add_append_makefile_var(append_to, flag_value)
    else:
        context.add_cond_makefile_var("%s_%s" % (prefix, suffix),
                                      flag_value)

def handle_ccode_check(args, conf, context):
    dep = conf["dependency"].upper()
    source = ""

    cflags = conf.get("cflags", {})
    ldflags = conf.get("ldflags", {})

    defines = conf.get("defines", [])
    headers = conf.get("headers", [])

    for define in defines:
        source += "#define %s\n" % define

    for header in headers:
        source += "#include %s\n" % header

    common_cflags = context.find_makefile_var(args.common_cflags_var)
    common_ldflags = context.find_makefile_var(args.common_ldflags_var)

    test_cflags = (cflags.get("value", ""), args.cflags, common_cflags)
    test_ldflags = (ldflags.get("value", ""), args.ldflags, common_ldflags)

    fragment = conf.get("fragment") or ""
    source = cstub.format(headers=source, fragment=fragment)
    success = compile_test(source, args.compiler, (" ").join(test_cflags),
                           (" ").join(test_ldflags))

    if success:
        context.add_kconfig("HAVE_%s" % dep, "bool", "y")
        if cflags:
            set_makefile_compflags(cflags, dep, "CFLAGS")
        if ldflags:
            set_makefile_compflags(ldflags, dep, "LDFLAGS")
    else:
        context.add_kconfig("HAVE_%s" % dep, "bool", "n")

    return success


def handle_exec_check(args, conf, context):
    dep = conf.get("dependency")
    dep_sym = dep.upper()
    exe = conf.get("exec")
    atleast_ver = conf.get("atleast-version")
    max_ver = conf.get("max-version")
    exact_ver = conf.get("exact-version")
    cmd = conf.get("version-command")
    ver_match = True
    version = None

    if not exe:
        context.info("Could not parse dependency: %s, no exec was specified.", dep)
        exit(1)

    path = which(exe)
    required = conf.get("required")

    if exact_ver or max_ver or atleast_ver:
        if not cmd:
            context.info("Could not parse dependency: %s, version requested "
                "but no version-command to fetch it was specified.", dep)
            exit(1)

        result, status = run_command(cmd, context)
        if not status:
            ver_match = False
        elif (exact_ver and result != exact_ver) or \
            (max_ver and result > max_ver) or \
            (atleast_ver and result < atleast_ver):
            version = result
            ver_match = False

    if required:
        if not path:
            req_label = context.find_makefile_var("NOT_FOUND")
            req_label += "executable: %s" % exe
            context.add_append_makefile_var("NOT_FOUND", req_label)
        elif not ver_match:
            req_label = context.find_makefile_var("NOT_FOUND")
            req_label += "%s version: %s" % (exe, version)
            context.add_append_makefile_var("NOT_FOUND", req_label)

    context.add_cond_makefile_var(dep_sym, path)

    success = bool(path) and ver_match

    if success:
        dir_path = os.path.dirname(os.path.realpath("%s" % path))
        context.add_cond_makefile_var("%s_DIR" % dep_sym, dir_path)

    context.add_kconfig("HAVE_%s" % dep_sym, "bool", "y" if success else "n")

    return success

def handle_python_check(args, conf, context):
    dep = conf.get("dependency")
    required = conf.get("required", False)
    pkgname = conf.get("pkgname")

    if not pkgname:
        context.info("Could not parse dependency: %s, no pkgname specified.", dep)
        exit(1)

    source = "import %s" % pkgname

    f = tempfile.NamedTemporaryFile(suffix=".py",delete=False)
    f.write(bytes(source, 'UTF-8'))
    f.close()

    cmd = "%s %s" % (sys.executable, f.name)
    context.debug("Testing python code:\n%s", source)
    output, status = run_command(cmd, context)

    success = bool(status)

    if required and not success:
        req_label = context.find_makefile_var("NOT_FOUND")
        req_label += "python%s module: %s\\n" % (sys.version_info[0], pkgname)
        context.add_append_makefile_var("NOT_FOUND", req_label, True)

    context.add_cond_makefile_var("HAVE_PYTHON_%s" % dep.upper(), "y" if success else "n")
    os.unlink(f.name)

    return success

def test_file_path(path, files):
    files_len = len(files)
    for curr in files:
        exists = os.path.exists(os.path.join(path, curr))
        context.debug("Lookingup file: %r at %r: %s" % (curr, path, exists))
        if exists:
            files_len = files_len - 1
    return files_len == 0

def handle_filesystem_check(args, conf, context):
    dep = conf.get("dependency")
    files = conf.get("files", [])
    path = conf.get("path", {})

    variables = dict(os.environ)
    variables['TOP_SRCDIR'] = os.getcwd()

    for k,v in context.makefile_vars.items():
        variables[k] = v["value"]

    dest = path
    vars_expand(dest, variables, len(dest))

    found_path = None
    for k,v in path.items():
        curr_path = variables.get(k)
        if not curr_path:
            context.debug("Variable $%s is not set", v)
            continue
        r = test_file_path(curr_path, files)
        if r:
            found_path = os.path.abspath(curr_path)
            break

    if found_path:
        context.add_kconfig("HAVE_%s" % dep.upper(), "bool", "y")
        context.add_cond_makefile_var("%s_PATH" % dep.upper(), found_path)
        return True
    else:
        context.add_kconfig("HAVE_%s" % dep.upper(), "bool", "n")
        return False

def handle_flags_check(args, conf, context, cflags, ldflags):
    append_to = conf.get("append_to")
    source = cstub.format(headers="", fragment="(void)argc; (void)argv;")

    if not cflags and not ldflags:
        context.info("Neither cflags nor ldflags provided to flags_check.")
        exit(1)

    if not cflags:
        cflags = []
    if not ldflags:
        ldflags = []

    def flags_compile(local_cflags, local_ldflags):
        """Helper to compile given empty source using the args.compiler
           and given local CFLAGS and LDFLAGS, prepending -Werror.
        """
        return compile_test(source, args.compiler,
                           " ".join(["-Werror"] + local_cflags),
                           " ".join(local_ldflags))

    if flags_compile(cflags, ldflags):
        context.add_append_makefile_var(append_to,
                                        " ".join(cflags + ldflags))
        return True

    supported_cflags = []
    for ci in cflags:
        # must acumulate the tested one so we handle dependent flags like -Wformat*
        if flags_compile(supported_cflags + [ci], []):
            supported_cflags.append(ci)

    supported_ldflags = []
    for cl in ldflags:
        if flags_compile(supported_ldflags + [cl], []):
            supported_ldflags.append(cl)

    if supported_cflags or supported_ldflags:
        context.add_append_makefile_var(append_to,
                                        " ".join(supported_cflags + supported_ldflags))
        return True

    return False

def handle_cflags_check(args, conf, context):
    return handle_flags_check(args, conf, context, conf.get("cflags"), None)

def handle_ldflags_check(args, conf, context):
    return handle_flags_check(args, conf, context, None, conf.get("ldflags"))

type_handlers = {
    "pkg-config": handle_pkgconfig_check,
    "ccode": handle_ccode_check,
    "exec": handle_exec_check,
    "python": handle_python_check,
    "cflags": handle_cflags_check,
    "ldflags": handle_ldflags_check,
    "filesystem": handle_filesystem_check,
}

def format_makefile_var(items):
    output = ""
    for k,v in sorted(items):
        if not v or not v["value"]: continue
        output += "%s %s %s\n" % (k, v["attrib"], v["value"].replace('#', '\\#'))
    return output

def makefile_gen(args, context):
    output = format_makefile_var(context.get_makefile_vars().items())
    f = open(args.makefile_output, "w+")
    f.write(output)
    f.close()

def kconfig_gen(args, context):
    output = ""
    for k,v in sorted(context.get_kconfig().items()):
        output += "config {config}\n{indent}{ktype}\n{indent}default {enabled}\n". \
                  format(config=k, indent="       ", ktype=v["type"], enabled=v["value"])
    f = open(args.kconfig_output, "w+")
    f.write(output)
    f.close()

def is_verbose():
    flag = os.environ.get("V")
    if not flag:
        return False
    try:
        flag = int(flag) != 0
    except ValueError:
        flag = flag.lower() in ("true", "yes", "on", "enabled")
    finally:
        return flag

def run(args, dep_checks, context):
    verbose = is_verbose()

    for dep in dep_checks:
        context.debug("Testing dependency: %s, type: %s", dep["dependency"], dep["type"])
        handler = type_handlers.get(dep["type"])
        if not handler:
            context.info("Parsing %s.", args.dep_config.name)
            context.info("Invalid type: %s at: %s", dep["type"], dep)
            exit(1)

        result = handler(args, dep, context)
        context.debug("##########################################################")

        if verbose:
            s = "Checking for %s%s... %s" % (dep["dependency"],
                                " (optional)" if not dep.get("required") else "",
                                "found." if result else "not found.")
            context.info(s)

def vars_expand(origin, dest, maxrec):
    remaining = {}

    if not maxrec:
        return

    for k,v in origin.items():
        if not isinstance(v, str):
            dest[k] = v
            continue

        try:
            dest[k] = re.sub("//*", "/", (v.format(**dest)))
        except KeyError:
            remaining[k] = v

    if remaining:
        vars_expand(remaining, dest, maxrec - 1)

def cache_persist(args, context):
    cache = open(args.cache, "wb")
    pickle.dump(context, cache, pickle.HIGHEST_PROTOCOL)
    cache.close()

def log_environment(context):
    context.debug("%s\n", log_disclaimer)
    context.debug("## -------- ##")
    context.debug("## Platform ##")
    context.debug("## -------- ##\n\n")

    uname = os.uname()
    context.debug("hostname = %s", socket.gethostname())
    context.debug("uname -m = %s", uname.machine)
    context.debug("uname -r = %s", uname.release)
    context.debug("uname -s = %s", uname.sysname)
    context.debug("uname -v = %s\n", uname.version)

    processor = platform.processor()
    context.debug("uname -p = %s\n", processor if processor else "unknown")

    context.debug("## ----------- ##")
    context.debug("## Environment ##")
    context.debug("## ----------- ##\n\n")

    for k,v in sorted(os.environ.items()):
        context.debug("%s = %s", k, v)

    context.debug("\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--compiler", help="The gcc compiler[for headers based tests]",
                        type=str, default=default_compiler)
    parser.add_argument("--cflags", help="Additional cflags[for headers based tests]",
                        type=str, default="")
    parser.add_argument("--ldflags", help="Additional/environment ldflags",
                        type=str, default="")
    parser.add_argument("--pkg-config", help="What to use for pkg-config",
                        type=str, default="pkg-config")
    parser.add_argument("--kconfig-output", help="The kconfig fragment output file",
                        type=str, default="Kconfig.gen")
    parser.add_argument("--makefile-output", help="The makefile fragment output file",
                        type=str, default="Makefile.gen")
    parser.add_argument("--dep-config", help="The dependencies config file",
                        type=argparse.FileType("r"), default="data/jsons/dependencies.json")
    parser.add_argument("--common-cflags-var", help=("The makefile variable to "
                                                     "group common cflags"),
                        type=str, default="COMMON_CFLAGS")
    parser.add_argument("--common-ldflags-var", help=("The makefile variable to "
                                                      "group common ldflags"),
                        type=str, default="COMMON_LDFLAGS")
    parser.add_argument("--cache", help="The configuration cache.", type=str,
                        default=".config-cache")
    parser.add_argument("--makefile-gen", help="Should generate Makefile.gen?",
                        action="store_true")
    parser.add_argument("--kconfig-gen", help="Should generate Kconfig.gen?",
                        action="store_true")
    parser.add_argument("--config-log", help="Config log file", type=str, default="config.log")

    args = parser.parse_args()

    if args.compiler != default_compiler and not which(shlex.split(args.compiler)[0]):
        print("ERROR: Invalid --compiler argument, no such file: %s" % args.compiler)
        exit(1)

    context = None
    conf = json.loads(args.dep_config.read())
    if os.path.isfile(args.cache):
        cache = open(args.cache, "rb")
        context = pickle.load(cache)
        cache.close()
    else:
        dep_checks = conf.get("dependencies")
        pre_checks = conf.get("pre-dependencies")

        context = DepContext(args.config_log)
        log_environment(context)

        context.debug("## ---------- ##")
        context.debug("## Core tests ##")
        context.debug("## ---------- ##\n\n")

        run(args, pre_checks, context)

        context.debug("## ---------------- ##")
        context.debug("## Dependency tests ##")
        context.debug("## ---------------- ##\n\n")

        run(args, dep_checks, context)
        cache_persist(args, context)

    if args.makefile_gen:
        makefile_gen(args, context)
        cache_persist(args, context)

    if args.kconfig_gen:
        kconfig_gen(args, context)
