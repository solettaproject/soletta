{
  "$schema": "http://solettaproject.github.io/soletta/schemas/node-type-genspec.schema",
  "name": "iio",
  "meta": {
    "author": "Intel Corporation",
    "license": "Apache-2.0",
    "version": "1"
  },
  "types": [
    {
      "category": "input/hw",
      "description": "IIO based gyroscope input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a gyroscope reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a gyroscope configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "gyroscope_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_GYROSCOPE__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_GYROSCOPE__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_GYROSCOPE__OUT__OFFSET",
            "reader_cb": "iio_direction_vector_reader_cb"
       }
      },
      "name": "iio/gyroscope",
      "aliases": [
          "gyroscope/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of direction-vector packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "direction-vector",
         "description": "Angular speed in all X/Y/Z axes, in radians per second.",
         "name": "OUT"
        },
        {
         "data_type": "direction-vector",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "direction-vector",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_direction_vector_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based magnet input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a magnet reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a magnet configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "magnet_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_MAGNETOMETER__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_MAGNETOMETER__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_MAGNETOMETER__OUT__OFFSET",
            "reader_cb": "iio_direction_vector_reader_cb"
       }
      },
      "name": "iio/magnetometer",
      "aliases": [
          "magnetometer/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Oversampling ratio measurement of the sensor",
             "name": "oversampling_ratio"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "direction-vector",
         "description": "Magnet location in all X/Y/Z axes, in Gauss.",
         "name": "OUT"
        },
        {
         "data_type": "direction-vector",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "direction-vector",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_direction_vector_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based temperature input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a temperature reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a temperature configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "temperature_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_THERMOMETER__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_THERMOMETER__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_THERMOMETER__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/thermometer",
      "aliases": [
          "thermometer/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset option.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": 0,
             "description": "Oversampling ratio measurement of the sensor",
             "name": "oversampling_ratio"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Temperature read, in milli degrees Celsius",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based pressure input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a pressure reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a pressure configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "pressure_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_PRESSURE_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_PRESSURE_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_PRESSURE_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/pressure-sensor",
      "aliases": [
          "pressure-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": 0,
             "description": "Oversampling ratio measurement of the sensor",
             "name": "oversampling_ratio"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Pressure data read in Kpa.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based color input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a color reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a color configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "color_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__OUT",
            "scale_red_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__SCALE_RED",
            "scale_green_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__SCALE_GREEN",
            "scale_blue_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__SCALE_BLUE",
            "offset_red_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__OFFSET_RED",
            "offset_green_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__OFFSET_GREEN",
            "offset_blue_port": "SOL_FLOW_NODE_TYPE_IIO_COLOR_SENSOR__OUT__OFFSET_BLUE",
            "reader_cb": "iio_color_reader_cb"
       }
      },
      "name": "iio/color-sensor",
      "aliases": [
          "color-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device Red raw readings",
             "name": "scale_red"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device Green raw readings",
             "name": "scale_green"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device Blue raw readings",
             "name": "scale_blue"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device Red raw readings",
             "name": "offset_red"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device Green raw readings",
             "name": "offset_green"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device Blue raw readings",
             "name": "offset_blue"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of direction-vector packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "rgb",
         "description": "Color Sensor data read.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE_RED"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE_GREEN"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE_BLUE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET_RED"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET_GREEN"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET_BLUE"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_color_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based accelerate input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a accelerate reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a accelerate configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "accelerate_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_ACCELEROMETER__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_ACCELEROMETER__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_ACCELEROMETER__OUT__OFFSET",
            "reader_cb": "iio_direction_vector_reader_cb"
       }
      },
      "name": "iio/accelerometer",
      "aliases": [
          "accelerometer/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "direction-vector",
             "default": {},
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of direction-vector packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "direction-vector",
         "description": "Accelerate data read, in m/s^2.",
         "name": "OUT"
        },
        {
         "data_type": "direction-vector",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "direction-vector",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_direction_vector_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based humidity input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a humidity reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a humidity configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "humidity_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_HUMIDITY_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_HUMIDITY_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_HUMIDITY_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/humidity-sensor",
      "aliases": [
          "humidity-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Relative humidity data read, in percentage(%rh).",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based adc input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a adc reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a adc configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "adc_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_ADC__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_ADC__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_ADC__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/adc",
      "aliases": [
          "adc/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Channel id. If -1, use the default channel",
             "name": "channel_id"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "ADC data read from analog signal, in milivolts(mV)",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
    },
    {
      "category": "input/hw",
      "description": "IIO based light input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "light_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_LIGHT_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_LIGHT_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_LIGHT_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/light-sensor",
      "aliases": [
          "light-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Channel id. If -1, use the default channel",
             "name": "channel_id"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Light data read in lux.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
     },
    {
      "category": "input/hw",
      "description": "IIO based intensity input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "intensity_both_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_BOTH_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_BOTH_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_BOTH_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/intensity-both-sensor",
      "aliases": [
          "intensity-both-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Channel id. If -1, use the default channel",
             "name": "channel_id"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Unit-less light intensity.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
     },
    {
      "category": "input/hw",
      "description": "IIO based intensity ir input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a light configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "intensity_ir_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_IR_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_IR_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_INTENSITY_IR_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/intensity-ir-sensor",
      "aliases": [
          "intensity-ir-sensor/iio"
      ],
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Channel id. If -1, use the default channel",
             "name": "channel_id"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "Unit-less light intensity.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
     },
     {
      "category": "input/hw",
      "description": "IIO based proximity input node. As any IIO device, it can use a buffer to get the readings. To use a buffer, define a size > 0 on buffer size. Readings are sent to the buffer via a trigger mechanism. Set iio_trigger_name to a valid iio trigger name in order to use buffer. If buffer is enabled but no iio_trigger_name was set, it will attempt to create a default trigger that will be activated when sending packets to TICK port.",
      "in_ports": [
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a proximity reading and produce packets on each of the the output ports. If buffer is enabled, current trigger must accept manual activation (default one, sysfs trigger, does).",
          "name": "TICK",
          "methods": {
            "process": "iio_common_tick"
          }
        },
        {
          "data_type": "any",
          "description": "Packets sent in here will trigger a proximity configuration attribute reading.",
          "name": "TRIGGER",
          "methods": {
            "process": "iio_get_info"
          }
        }
      ],
      "methods": {
        "close": "iio_common_close",
        "open": "proximity_open"
      },
      "node_type": {
        "access": [
            "base"
        ],
        "data_type": "struct iio_node_type",
        "extra_methods": {
            "out_port": "SOL_FLOW_NODE_TYPE_IIO_PROXIMITY_SENSOR__OUT__OUT",
            "scale_port": "SOL_FLOW_NODE_TYPE_IIO_PROXIMITY_SENSOR__OUT__SCALE",
            "offset_port": "SOL_FLOW_NODE_TYPE_IIO_PROXIMITY_SENSOR__OUT__OFFSET",
            "reader_cb": "iio_double_reader_cb"
       }
      },
      "name": "iio/proximity-sensor",
      "options": {
       "members": [
         {
           "data_type": "string",
           "description": "IIO device identifier. It's a space separated list of commands. For commands, if it's an integer value, will be interpreted as IIO device id. If it's a string starting with '/', will be interpreted as absolute path of IIO device on sysfs. If it's on the form 'i2c/X-YYYY', will evaluate to an i2c device on sysfs, where X is the bus number and YYYY is the device number, eg, 7-0069, for device 0x69 on bus 7. If it's on the form 'create,i2c,<rel_path>,<devnumber>,<devname>', where rel_path is the path of bus relative to '/sys/devices', them it will attempt to create an IIO device on that i2c bus and use it.",
           "name": "iio_device"
         },
         {
           "data_type": "int",
           "description": "IIO buffer size. If -1, buffering is disabled. If 0, will use default buffer size. If enabled (> 0), a trigger is necessary to perform readings. Set it using 'iio_trigger_name'; if no trigger name is set, it will attempt to create a default one, which is activated via TICK port.",
           "default": 0,
           "name": "buffer_size"
         },
         {
           "data_type": "string",
           "description": "IIO trigger name. Name of IIO trigger that should be associated to this device for buffered readings. Set to hrtimer:<trigger name> if want to use hrtimer trigger. If not set and buffer enabled, will try to use device current trigger, if any. If none, will attempt to create a sysfs or hrtimer trigger",
           "name": "iio_trigger_name",
           "default": null
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default scale. If false, it will attempt to use scale option.",
           "name": "use_device_default_scale"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Scale to applied to device raw readings",
             "name": "scale"
         },
         {
           "data_type": "boolean",
           "default": true,
           "description": "If should use device own default offset. If false, it will attempt to use offset_x, offset_y and offset_z options.",
           "name": "use_device_default_offset"
         },
         {
             "data_type": "float",
             "default": 0,
             "description": "Offset to be added to device raw readings",
             "name": "offset"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Sampling frequency of the sensor. If -1, use device default",
             "name": "sampling_frequency"
         },
         {
             "data_type": "int",
             "default": -1,
             "description": "Channel id. If -1, use the default channel",
             "name": "channel_id"
         },
         {
             "data_type": "drange-spec",
             "default": {
               "max": "DBL_MAX",
               "min": "-DBL_MAX",
               "step": "DBL_MIN"
             },
             "description": "Range of output packet. Usually, is the output range of used sensor. It'll be the 'min' and 'max' fields of drange packets sent on OUT port.",
             "name": "out_range"
         }
       ],
       "version": 1
      },
      "out_ports": [
        {
         "data_type": "float",
         "description": "proximity data read.",
         "name": "OUT"
        },
        {
         "data_type": "float",
         "description": "Scale to applied to device raw readings",
         "name": "SCALE"
        },
        {
         "data_type": "float",
         "description": "Offset to be added to device raw readings",
         "name": "OFFSET"
        },
        {
         "data_type": "int",
         "description": "Sampling frequency of the sensor. If -1, use device default",
         "name": "SAMPLING_FREQUENCY"
        }
      ],
      "private_data_type": "iio_double_data"
     }
 ]
}
